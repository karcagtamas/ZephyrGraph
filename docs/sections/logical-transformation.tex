\chapter{Transformation of Cause-Effect Graphs into Logical Formulas and CNF}
\label{ch:logical-transformation}

\section{Graph to Logic Transformation}

Converting cause-effect graphs into logical formulas is a crucial step toward achieving automated test generation. This process formalizes the visual relationships in the graph into Boolean expressions, making them suitable for analysis or future use. The objective is to transform the structured graph, which visually represents business logic, into a set of logical rules that can be efficiently processed later.

\subsection{Step 1: Identifying Causes and Effects}

The first step in the transformation is to map the causes and effects in the graph to Boolean variables. Each cause and effect node in the graph corresponds to a variable that can take a value of either true (1) or false (0).

For example:

\begin{compactitem}
    \item \textbf{Cause 1 (C1)}: User enters a valid username → Boolean variable \textbf{C1}
    \item \textbf{Cause 2 (C2)}: User enters a valid password → Boolean variable \textbf{C2}
    \item \textbf{Effect 1 (E1)}: User is granted access → Boolean variable \textbf{E1}
\end{compactitem}

\subsection{Step 2: Defining Logical Relationships}

The logical relationships between causes and effects are then defined using nodes. Each logical operator (AND, OR, NOT) in the graph is represented as a Boolean expression. These logical nodes are subsequently translated into corresponding operations within the formula.

For example:

\begin{compactitem}
    \item \textbf{AND Node}: $ C1 \land C2 \rightarrow E1 $ (both conditions must be true for the outcome to occur)
    \item \textbf{OR Node}: $ C1 \lor C2 \rightarrow E1 $ (at least one of the conditions must be true for the outcome to occur)
    \item \textbf{NOT Node}: $ \lnot C3 \rightarrow E2 $ (the negation of a condition, indicating that the outcome occurs when the condition is false)
\end{compactitem}

\subsection{Step 3: Applying Boolean Algebra}

Once the logical relationships are established, Boolean algebra is used to simplify and formalize the relationships. For each combination of causes and effects, a corresponding formula is created. This formula will express the exact conditions under which an effect occurs based on the causes.

For instance, if an effect \textbf{E1} occurs only when both \textbf{C1} and \textbf{C2} are true, the corresponding logical formula would be: $ E1 = C1 \land C2 $.

\subsection{Step 4: Handling Complex and Nested Conditions}

For graphs with nested conditions or complex dependencies, the transformation involves breaking down the graph into simpler components. Each sub-condition is transformed individually before being combined into the final logical expression.

For example, consider the following graph logic: $ (C1 \land C2) \lor (C3 \land \lnot C4) \rightarrow E1 $. This represents a scenario where \textbf{E1} occurs if either both \textbf{C1} and \textbf{C2} are true, or \textbf{C3} is true while \textbf{C4} is false. The transformation results in the following Boolean formula: $ E1 = (C1 \land C2) \lor (C3 \land \lnot C4) $

This formula captures the decision-making logic of the system by accounting for all relevant conditions.

\subsubsection{Handling Constraints and Dependencies}

In some cases, certain conditions or dependencies in the business logic must also be modeled, such as mutually exclusive outcomes or constraints on the input values. These constraints are incorporated into the logical formulas, ensuring that only valid combinations of causes are tested.

For example, if \textbf{C1} and \textbf{C4} are mutually exclusive, the formula must reflect this: $ C1 \land C4 = false $

This ensures that test cases generated from the formula will not include invalid or contradictory conditions.

\subsection{Step 5: Generating Conjunctive Normal Form (CNF)}

In many cases, the logical formula needs to be converted into Conjunctive Normal Form (CNF) to be used with certain solvers or test generation tools. CNF is a standardized format where the formula is expressed as a conjunction of disjunctions, making it easier to handle by many automated tools.

For example, the expression $ E1 = (C1 \land C2) \lor (C3 \land \lnot C4) $ can be rewritten in CNF: $ (\lnot C1 \lor \lnot C3) \land (\lnot C2 \lor C4) $

\subsection{Step 6: Optimizing and Finalizing the Logic}

Once the logical formulas are generated, they are often optimized to reduce complexity and eliminate redundancy. This ensures that the formulas are as efficient as possible while preserving their ability to model all necessary business logic.

Finally, the generated logical formulas are analyzed and optimized to remove any redundancy or unnecessary complexity. This ensures that the resulting expressions are minimal and efficient for use in test generation. The optimized logic is then ready for input into a solver or test automation tool, where it can be used to generate test cases that cover all possible combinations of causes and effects.

\section{Example Conversion}

To illustrate the transformation of a cause-effect graph into logical formulas, let's walk through a simple example. We will take a basic cause-effect scenario and convert it into a set of Boolean expressions that can be used for automated test generation.

\subsection{Step 1: Define the Causes and Effects}

Consider a system where a user must input both a valid username and password to gain access. The cause-effect graph would include the following elements:

\begin{compactitem}
    \item \textbf{Cause 1 (C1)}: Valid username provided
    \item \textbf{Cause 2 (C2)}: Valid password provided
    \item \textbf{Effect 1 (E1)}: Access granted
    \item \textbf{Effect 2 (E2)}: Access denied
\end{compactitem}

\subsection{Step 2: Establish Logical Relationships}

In this example, the system grants access only if both the username and password are valid. If either the username or password is invalid, access is denied. The cause-effect graph would visually represent these relationships with AND and NOT nodes:

\begin{compactitem}
    \item E1 = C1 AND C2 (access is granted only if both the username and password are valid)
    \item E2 = NOT (C1 AND C2) (access is denied if either the username of password is invalid)
\end{compactitem}

\subsection{Step 3: Representing the Logic in Boolean Form}

Based on the cause-effect graph, we can now convert the relationships into Boolean expressions:

\begin{compactitem}
    \item \textbf{Access granted (E1)}: $ E1 = C1 \land C2 $
    \item \textbf{Access deined (E2)}: $ E2 = \lnot (C1 \land C2) = (\lnot C1 \lor \lnot C2) $
\end{compactitem}

It is evident that the E2 formula can be simplified. By applying De Morgan's law, the negation is pushed inside the AND operation, transforming it into an OR operation.

\subsection{Step 4: Converting to Conjunctive Normal Form (CNF)}

We would convert the Boolean expressions into this CNF form. The formula is expressed as a set of OR clauses that are ANDed together.

In this example, the formula for access denied (E2) is already in CNF form: $ E2 = (\lnot C1 \lor \lnot C2) $

The formula for access granted (E1) can be expressed in CNF by leaving it as a simple conjunction: $ E1 = C1 \land C2 $

\subsection{Step 5: Validation the Logical Formulas}

Once the conversion is complete, the generated logical formulas can be validated. These formulas now represent the decision-making logic of the system, ensuring that access is correctly granted or denied based on the inputs.

For instance:

\begin{compactitem}
    \item If both \textbf{C1 = 1} and \textbf{C2 = 1} (valid username and password), \textbf{E1 = 1} (access granted)
    \item If either \textbf{C1 = 0} or \textbf{C2 = 0} (invalid username or password), \textbf{E2 = 1} (access denied)
\end{compactitem}

\section{Importance of CNF}

Converting logical formulas derived from cause-effect graphs into Conjunctive Normal Form (CNF) is a critical step for several reasons, particularly in the context of automated testing and logic-based analysis.

\begin{enumerate}
    \item \textbf{Standardization for Solvers}: Many automated testing tools and satisfiability solvers (SAT solvers) require input in CNF to function efficiently. CNF provides a standardized structure, making it easier for these tools to process and analyze the logic. From the CNF forumlas, the system can leverage these solvers to identify satisfiable inputs, detect inconsistencies, or generate optimized test cases.
    \item \textbf{Improved Computational Efficiency}: CNF reduces the complexity of evaluating logical expressions. It breaks down complex logical relationships into smaller, manageable units (clauses), each of which is a disjunction of literals. These clauses can be evaluated independently, which speeds up the process of checking satisfiability and make the system more scalable.
    \item \textbf{Simplifying the Logic}: CNF inherently simplifies the logical structure by breaking down complex relationships into basic logical operations. This simplification is particularly useful when dealing with intricate business logic, as it makes it easier to understand and debug the logic. Simplified expressions in CNF also reduce the likelihood of errors.
    \item \textbf{Compatibility with Other Logical Techniques}: CNF is widely used in conjunction with other formal methods and logic-based techniques, such as model checking and theorem proving. Having the logic represented in CNF allows the system to integrate smoothly with a variety of verification tools and techniques.
\end{enumerate}

By converting cause-effect graphs into CNF, the system gains efficiency, scalability, and compatibility with existing logic-based tools, ensuring a more rigorous and comprehensive testing approach.

\section{Algorithm for CNF Conversion}

Through transformation, simplification, and optimization, we can convert a logical formula into Conjunctive Normal Form. The process will take a logical formula as input and produce an equivalent logical formula in CNF as output.

\begin{enumerate}
    \item Move negations inward
        \begin{itemize}
            \item Apply \textbf{De Morgan's laws} to push the negations inside:
                \begin{itemize}
                    \item Convert $ \lnot (A \land B) $ to $ \lnot A \lor \lnot B $.
                    \item Convert $ \lnot (A \lor B) $ to $ \lnot A \land \lnot B $.
                \end{itemize}
            \item Continue applying this step until all negations are directly applied to literals.
        \end{itemize}
    \item Distribute \textbf{AND} over \textbf{OR}
        \begin{itemize}
            \item If the formula is in the form $ A \lor (B \land C) $, apply the distribution law to transform it to $ (A \lor B) \land (A \lor C) $.
            \item Continue this step recursively.
        \end{itemize}
    \item Simplify the formula
        \begin{itemize}
            \item Remove any duplicate literals within the disjunctions.
            \item Simplify multiple negations on the same literal.
            \item Eliminate any clasuses that are tautological.
        \end{itemize}
\end{enumerate}

By following these steps, the logical formula can be converted to CNF, making it suitable for subsequent processes.

\section{Example of CNF Transformation}

Let's explore a few specific examples of transforming logical formulas into CNF.

\begin{itemize}
    \item $ C1 \land (C2 \lor \lnot C1) $ is an unusual logical expression, but since it is already in CNF, no transformation is necessary. Although the simplification is possible to $ C1 \land C2 $ form.
    \item $ (C1 \lor \lnot C2) \land (\lnot C1 \lor C3) $ is a more complex logical expression; however, because it is a conjunction of disjunctions, it is already in CNF.
    \item $ \lnot (C1 \land C2) $ example is not CNF, so wee need to adjust it. By applying \textbf{De Morgan's law}, we can modify it to $ \lnot C1 \lor \lnot C2 $. This expression is now in CNF, as it is a disjunction of literals.
    \item For a more detailed example, consider the formula $ (C1 \land C2) \lor \lnot C3 $. By applying the \textbf{distribution law} (AND over OR), we can transform it into $ (C1 \lor \lnot C3) \land (C2 \lor \lnot C3) $, which is now in CNF.
\end{itemize}